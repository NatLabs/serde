import Array "mo:base/Array";
import Blob "mo:base/Blob";
import Char "mo:base/Char";
import Debug "mo:base/Debug";
import Decoder "../src/Decoder";
import Encoder "../src/Encoder";
import Iter "mo:base/Iter";
import Bool "mo:base/Bool";
import Nat "mo:base/Nat";
import Float "mo:base/Float";
import Nat8 "mo:base/Nat8";
import Principal "mo:base/Principal";
import Type "../src/Type";
import Value "../src/Value";
import Arg "../src/Arg";

module {
  public func run() {
      // Nat
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x00], #Nat, #Nat(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x01], #Nat, #Nat(1));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x7F], #Nat, #Nat(127));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0xE5, 0x8E, 0x26], #Nat, #Nat(624485));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x80, 0x80, 0x98, 0xF4, 0xE9, 0xB5, 0xCA, 0x6A], #Nat, #Nat(60000000000000000));

    // Nat8
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7B, 0x00], #Nat8, #Nat8(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7B, 0x10], #Nat8, #Nat8(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7B, 0x63], #Nat8, #Nat8(99));

    // Nat16
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7A, 0x00, 0x00], #Nat16, #Nat16(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7A, 0x10, 0x00], #Nat16, #Nat16(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7A, 0xE7, 0x03], #Nat16, #Nat16(999));

    // Nat32
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x79, 0x00, 0x00, 0x00, 0x00], #Nat32, #Nat32(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x79, 0x10, 0x00, 0x00, 0x00], #Nat32, #Nat32(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x79, 0xEA, 0x49, 0x08, 0x00], #Nat32, #Nat32(543210));
    
    // Nat64
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #Nat64, #Nat64(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #Nat64, #Nat64(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x78, 0xEA, 0x49, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00], #Nat64, #Nat64(543210));

    // Int
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x00], #Int, #Int(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x10], #Int, #Int(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x7C], #Int, #Int(-4));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x71], #Int, #Int(-15));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0xBC, 0x7F], #Int, #Int(-68));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0xE5, 0x8E, 0x26], #Int, #Int(624485));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0xC0, 0xBB, 0x78], #Int, #Int(-123456));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x80, 0x01], #Int, #Int(128));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x80, 0x80, 0xE8, 0x8B, 0x96, 0xCA, 0xB5, 0x95, 0x7F], #Int, #Int(-60000000000000000));

    // Int8
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0x00], #Int8, #Int8(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0x10], #Int8, #Int8(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0x63], #Int8, #Int8(99));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0xF1], #Int8, #Int8(-15));
    
    // Int16
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0x00, 0x00], #Int16, #Int16(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0x10, 0x00], #Int16, #Int16(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0xF1, 0xFF], #Int16, #Int16(-15));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0x0F, 0x27], #Int16, #Int16(9999));

    // Int32
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0x00, 0x00, 0x00, 0x00], #Int32, #Int32(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0x10, 0x00, 0x00, 0x00], #Int32, #Int32(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0xF1, 0xFF, 0xFF, 0xFF], #Int32, #Int32(-15));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0xFF, 0xFF, 0x00, 0x00], #Int32, #Int32(65535));
    
    // Int64
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #Int64, #Int64(0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #Int64, #Int64(16));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF], #Int64, #Int64(-15));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00], #Int64, #Int64(4294967295));

    // Float32
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x73, 0x00, 0x00, 0x80, 0x3F], #Float32, #Float32(1.0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x73, 0x10, 0x06, 0x9E, 0x3F], #Float32, #Float32(1.23456));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x73, 0xB7, 0xE6, 0xC0, 0xC7], #Float32, #Float32(-98765.4321));

    // // Float64
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F], #Float64, #Float64(1.0));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x72, 0x38, 0x32, 0x8F, 0xFC, 0xC1, 0xC0, 0xF3, 0x3F], #Float64, #Float64(1.23456));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x72, 0x8A, 0xB0, 0xE1, 0xE9, 0xD6, 0x1C, 0xF8, 0xC0], #Float64, #Float64(-98765.4321));
    
    // Bool
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7E, 0x01], #Bool, #Bool(true));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7E, 0x00], #Bool, #Bool(false));

    // Text
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x71, 0x00], #Text, #Text(""));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x71, 0x01, 0x41], #Text, #Text("A"));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x71, 0x2B, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6B, 0x20, 0x62, 0x72, 0x6F, 0x77, 0x6E, 0x20, 0x66, 0x6F, 0x78, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x73, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x7A, 0x79, 0x20, 0x64, 0x6F, 0x67], #Text, #Text("The quick brown fox jumps over the lazy dog"));

    // Principal
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x68, 0x01, 0x00], #Principal, #Principal(#transparent(Principal.fromText("aaaaa-aa"))));
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x68, 0x01, 0x1D, 0xFE, 0x97, 0x48, 0xF3, 0x57, 0x95, 0x3E, 0x20, 0xAC, 0xA9, 0x0D, 0xC2, 0x41, 0xC3, 0x37, 0x2E, 0xFE, 0x4A, 0x3A, 0xEE, 0xA0, 0xD7, 0xA9, 0xB9, 0xA1, 0x36, 0x8D, 0xE7, 0x02], #Principal, #Principal(#transparent(Principal.fromText("g4gvl-fx6s5-epgv4-vhyqk-zkiny-ja4gn-zo7zf-dv3va-26u3t-ijwrx-tqe"))));

    // Null
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7F], #Null, #Null);

    // Reserved
    test([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x70], #Reserved, #Reserved);

    // Opt
    test([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6E, 0x7C, 0x01, 0x00, 0x00], #Option(#Int), #Option(null));
    test([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6E, 0x7C, 0x01, 0x00, 0x01, 0x2A], #Option(#Int), #Option(?#Int(42)));
    test([0x44, 0x49, 0x44, 0x4C, 0x02, 0x6E, 0x7C, 0x6E, 0x00, 0x01, 0x01, 0x01, 0x01, 0x2A], #Option(#Option(#Int)), #Option(?#Option(?#Int(42))));

    // Vector
    test([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6D, 0x7C, 0x01, 0x00, 0x00], #Vector(#Int), #Vector([]));
    test([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6D, 0x7C, 0x01, 0x00, 0x02, 0x01, 0x02], #Vector(#Int), #Vector([#Int(1), #Int(2)]));

    // Record
    test([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6C, 0x01, 0x01, 0x7C, 0x01, 0x00, 0x2A], #Record([{tag=#hash(1); _type=#Int}]), #Record([{tag=#hash(1); value=#Int(42)}]));
    test([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6C, 0x02, 0x86, 0x8E, 0xB7, 0x02, 0x7C, 0xD3, 0xE3, 0xAA, 0x02, 0x7E, 0x01, 0x00, 0x01, 0x2A], #Record([{tag=#name("foo"); _type=#Int}, {tag=#name("bar"); _type=#Bool}]), #Record([{tag=#name("foo"); value=#Int(42)}, {tag=#name("bar"); value=#Bool(true)}]));
    
    test(
      [0x44, 0x49, 0x44, 0x4C, 0x04, 0x6E, 0x7C, 0x6C, 0x01, 0xA7, 0x8A, 0x83, 0x99, 0x08, 0x00, 0x6E, 0x01, 0x6C, 0x01, 0xA7, 0x8A, 0x83, 0x99, 0x08, 0x02, 0x01, 0x03, 0x01, 0x00],
      #Record([
        {
          tag=#name("selfRef");
          _type=#Option(#Record([
            {
              tag=#name("selfRef");
              _type=#Option(#Int)
            }
          ]))
        }
      ]),
      #Record([
        {
          tag=#name("selfRef");
          value=#Option(?#Record([
            {
              tag=#name("selfRef");
              value=#Option(null)
            }
          ]))
        }
      ])
    );

    // Variant
    test([0x44, 0x49, 0x44, 0x4C, 0x03, 0x6C, 0x05, 0xC4, 0xA7, 0xC9, 0xA1, 0x01, 0x79, 0xDC, 0x8B, 0xD3, 0xF4, 0x01, 0x79, 0x8D, 0x98, 0xF3, 0xE7, 0x04, 0x7C, 0xE2, 0xD8, 0xDE, 0xFB, 0x0B, 0x79, 0x89, 0xFB, 0x97, 0xEB, 0x0E, 0x71, 0x6B, 0x01, 0xCF, 0xA0, 0xDE, 0xF2, 0x06, 0x7F, 0x6B, 0x02, 0x9C, 0xC2, 0x01, 0x00, 0xE5, 0x8E, 0xB4, 0x02, 0x01, 0x01, 0x02, 0x01, 0x00],
     #Variant([
        {
          tag=#name("ok");
          _type=#Record([
            {
              tag=#name("total");
              _type=#Nat32
            },
            {
              tag=#name("desktop");
              _type=#Nat32
            },
            {
              tag=#name("time");
              _type=#Int
            },
            {
              tag=#name("mobile");
              _type=#Nat32
            },
            {
              tag=#name("route");
              _type=#Text
            }
          ])
        },
        {
          tag=#name("err");
          _type=#Variant([
            {
              tag=#name("NotFound");
              _type=#Null
            }
          ])
        }
      ]),
     #Variant({
        tag=#name("err");
        value=#Variant({
          tag=#name("NotFound");
          value=#Null
        })
      })
    );

    // Func
    test(
      [0x44, 0x49, 0x44, 0x4C, 0x03, 0x6E, 0x7D, 0x6D, 0x77, 0x6A, 0x02, 0x7C, 0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01, 0x00, 0x12, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x4E, 0x4E, 0x53, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E],
      #Func({
        modes=[#_query,#oneWay];
        argTypes=[#Int, #Option(#Nat)];
        returnTypes=[#Vector(#Int8)];
      }),
      #Func(#transparent({
        method="ExecuteNNSFunction";
        service=#transparent(Principal.fromText("aaaaa-aa"))
      }))
    );


    // Service
    test(
      [0x44, 0x49, 0x44, 0x4C, 0x04, 0x6E, 0x7D, 0x6D, 0x77, 0x6A, 0x02, 0x7C, 0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x69, 0x01, 0x12, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x4E, 0x4E, 0x53, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x02, 0x01, 0x03, 0x01, 0x00],
      #Service({
        methods=[
          (
            "ExecuteNNSFunction",
            {
              modes=[#_query,#oneWay];
              argTypes=[#Int, #Option(#Nat)];
              returnTypes=[#Vector(#Int8)];
            }
          )
        ]
      }),
      #Service(#transparent(Principal.fromText("aaaaa-aa")))
    );

    // Recursion

    test(
      [0x44, 0x49, 0x44, 0x4C, 0x02, 0x6E, 0x01, 0x6C, 0x01, 0xA7, 0x8A, 0x83, 0x99, 0x08, 0x00, 0x01, 0x01, 0x01, 0x00],
      #recursiveType({
        id="rec_1";
        _type=#Record([
          {
            tag=#name("selfRef");
            _type=#Option(#recursiveReference("rec_1"))
          }
        ])
      }),
      #Record([
        {
          tag=#name("selfRef");
          value=#Option(?#Record([
            {
              tag=#name("selfRef");
              value=#Option(null)
            }
          ]))
        }
      ])
    );

    // Duplicate Types are merged
    test(
      [0x44, 0x49, 0x44, 0x4C, 0x03, 0x6E, 0x7C, 0x6E, 0x7C, 0x6B, 0x02, 0x31, 0x00, 0x92, 0xFF, 0xC9, 0x93, 0x04, 0x01, 0x01, 0x02, 0x00, 0x01, 0x01],
     #Variant([
        {
          tag=#name("1");
          _type=#Option(#Int)
        },
        {
          tag=#name("dup1");
          _type=#Option(#Int)
        }
      ]),
     #Variant({
        tag=#name("1");
        value=#Option(?#Int(1))
      })
    )

  };

  private func test(bytes: [Nat8], t : Type.Type, arg: Value.Value) {
    Debug.print("Testing...\nType:  " # debug_show(t) # "\nValue: " # debug_show(arg) # "\nExpected Bytes: " # toHexString(bytes));
    let actualBytes: [Nat8] = Blob.toArray(Encoder.encode([{value=arg; _type=t}]));
    if (not areEqual(bytes, actualBytes)) {
        Debug.trap("Failed Byte Check.\nExpected Bytes: " # toHexString(bytes) # "\nActual Bytes:   " # toHexString(actualBytes) # "\nValue: " # debug_show(arg));
    };
    let args : ?[Arg.Arg] = Decoder.decode(Blob.fromArray(bytes));
    switch(args){
      case (null) {
        Debug.trap("Failed decoding.\nExpected Type: " # debug_show(t) # "\nExpected Value: " # debug_show(arg) # "\nBytes: " # toHexString(bytes))
      };
      case (?args) {
        if (args.size() != 1) {
          Debug.trap("Too many args: " # Nat.toText(args.size()));
        };
        let actualArg: Arg.Arg = args[0];
        if (not Type.equal(t, actualArg._type)) {
          Debug.trap("Failed Type Check.\nExpected Type: " # debug_show(t) # "\nActual Type: " # debug_show(actualArg._type));
        };
        if (not Value.equal(arg, actualArg.value)) {
          Debug.trap("Failed Value Check.\nExpected Value: " # debug_show(arg) # "\nActual Value: " # debug_show(actualArg.value));
        };
        Debug.print("Passed\n");
      }
    };
  };

  private func areEqual(b1: [Nat8], b2: [Nat8]) : Bool {
    if (b1.size() != b2.size()) {
      return false;
    };
    for (i in Iter.range(0, b1.size() - 1)) {
      if (b1[i] != b2[i]) {
          return false;
      };
    };
    true;
  };

  private func toHexString(array : [Nat8]) : Text {
    Array.foldLeft<Nat8, Text>(array, "", func (accum, w8) {
      var pre = "";
      if(accum != ""){
          pre #= ", ";
      };
      accum # pre # encodeW8(w8);
    });
  };
  private let base : Nat8 = 0x10; 

  private let symbols = [
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
  ];
  /**
  * Encode an unsigned 8-bit integer in hexadecimal format.
  */
  private func encodeW8(w8 : Nat8) : Text {
    let c1 = symbols[Nat8.toNat(w8 / base)];
    let c2 = symbols[Nat8.toNat(w8 % base)];
    "0x" # Char.toText(c1) # Char.toText(c2);
  };
}